<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>メモツール</title>
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <style>
    html, body { height: 100%; margin: 0; padding: 18px; box-sizing: border-box; }
    body { display: flex; flex-direction: column; font-family: sans-serif; }
    .controls { flex: 0 0 auto; margin-bottom: 10px; position: relative; }
    .controls button, .controls input {
      margin-right: 5px;
      padding: 7px 7px;
      font-size: 12px;
    }
    #memo {
      flex: 1 1 auto;
      width: 100%;
      border: 1px solid #ccc;
      padding: 10px;
      overflow: auto;
      white-space: pre-wrap;
      font-family: monospace;
    }
    .highlight { background-color: yellow; }
    #transform-window {
      display: none;
      position: fixed;
      top: 15%;
      left: 50%;
      transform: translateX(-50%);
      background: #fff;
      border: 1px solid #ccc;
      padding: 20px;
      z-index: 1000;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
      max-height: 70vh;
      overflow-y: auto;
      width: min(400px, 92vw);
    }
    #transform-window label {
      display: block;
      margin: 10px 0 5px;
    }
    #transform-window input[type="text"], #transform-window input[type="number"] {
      width: 100%;
      padding: 5px;
      margin-bottom: 10px;
      box-sizing: border-box;
      font-family: monospace;
    }
    #transform-window button {
      padding: 5px 10px;
      margin-right: 5px;
    }
    #close-transform {
      position: absolute;
      top: 5px;
      right: 5px;
      cursor: pointer;
      font-weight: bold;
    }
    #download-window {
      display: none;
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      background: #fff;
      border: 1px solid #ccc;
      padding: 20px;
      z-index: 1000;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
    }
    #close-download { float: right; }

    .feature-container {
      border-top: 1px solid #eee;
      padding-top: 10px;
      margin-top: 10px;
    }

    /* 文字数ボタンとメニュー */
    #char-count-btn {
      min-width: 3.5em;
      font-variant-numeric: tabular-nums;
    }
    #char-count-menu {
      position: fixed;
      display: none;
      background: #fff;
      border: 1px solid #ccc;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
      padding: 8px 10px;
      z-index: 1200;
      font-size: 12px;
      line-height: 1.6;
    }
    #char-count-menu label { display: block; cursor: pointer; }
    #splitButtons { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 6px; }
    #splitButtons button { text-align: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .muted { color: #777; font-size: 11px; }
  </style>
</head>
<body>
  <div class="controls">
    <button id="undo">←</button>
    <button id="redo">→</button>
    <button id="clear">クリア</button>
    <button id="copy">コピー</button>
    <input id="search" type="text" placeholder="🔎 キーワード検索">
    <button id="prev"><</button>
    <span id="count">0/0</span>
    <button id="next">></button>
    <input id="prefix" type="text" placeholder="始め">
    <input id="suffix" type="text" placeholder="終わり">
    <button id="add-prefix-suffix">追加</button>
    <button id="exec-js">JavaScriptを実行</button>
    <button id="exec-html">HTMLを実行</button>
    <button id="exec-bm">▽</button>
    <button id="transform">★</button> <button id="open-url">＋</button>
    <button id="download-btn">🖥️</button>
    <!-- 文字数カウンタ -->
    <button id="char-count-btn" title="文字数">0</button>
    <div id="char-count-menu">
      <strong>カウントモード</strong>
      <label><input type="radio" name="countMode" value="default" checked> デフォルト（全て=1）</label>
      <label><input type="radio" name="countMode" value="xpost"> Xポスト用（半角=1 / 全角=2）</label>
      <div class="muted">※ 範囲選択中は選択部分をカウント</div>
    </div>

    <div id="download-window">
      <button id="close-download">☒</button>
      <div>
        <label>ファイル名</label><br>
        <input id="filename" type="text" placeholder="example"><br><br>
        <label>拡張子</label><br>
        <input id="extension" type="text" placeholder="txt"><br><br>
        <button id="save-file">保存</button>
      </div>
    </div>

    <div id="transform-window">
      <div id="close-transform">☒</div>

      <label><input type="radio" name="action" value="encode" checked> エンコード</label>
      <label><input type="radio" name="action" value="decode"> デコード</label>
      <label><input type="radio" name="action" value="remove"> コメント削除</label>
      <label><input type="radio" name="action" value="remove1"> コメント削除(1文)</label>
      <label><input type="radio" name="action" value="custom"> カスタム</label>
      <label><input type="radio" name="action" value="pc_view"> PC表示</label>
      <label><input type="radio" name="action" value="github_import"> GitHubインポート</label>
      <!-- ★ 分割コピー（GitHubインポートと同期の間） -->
      <label><input type="radio" name="action" value="split_copy"> 分割コピー</label>
      <label><input type="radio" name="action" value="sync"> 同期</label>

      <!-- カスタム変換 -->
      <div id="customMapping" class="feature-container" style="display: none;">
        <label for="customFrom">カスタム変換 (変換元 → 変換先)</label>
        <input type="text" id="customFrom" placeholder="変換元（空白も可）">
        <input type="text" id="customTo" placeholder="変換先（空欄で削除 / 空白も可）">
        <div class="muted">※ 変換元が<span style="text-decoration:underline;">空欄</span>のときは変換しません（安全）。変換先が空欄なら削除として機能します。</div>
      </div>

      <!-- GitHubインポート -->
      <div id="githubImportContainer" class="feature-container" style="display: none;">
        <label for="githubUrl">GitHubのURL</label>
        <input type="text" id="githubUrl" placeholder="リポジトリ or Raw URL">
        <button id="importGithubBtn">インポート</button>
      </div>

      <!-- 分割コピー -->
      <div id="splitCopyContainer" class="feature-container" style="display: none;">
        <label for="splitSize">分割サイズ（文字数）</label>
        <input type="number" id="splitSize" min="1" value="19000">
        <div id="splitButtons"></div>
      </div>

      <!-- 同期 -->
      <div id="syncContainer" class="feature-container" style="display: none;">
        <label for="syncWord">同期ワード</label>
        <input type="text" id="syncWord" placeholder="秘密の言葉">
        <label><input type="checkbox" id="syncSend"> 送信</label>
        <label><input type="checkbox" id="syncReceive"> 受信</label>
        <button id="syncBtn">同期</button>
      </div>

      <button id="convertButton" style="margin-top: 15px;">変換</button>
    </div>
  </div>

  <div id="memo" contenteditable="true"></div>

  <script>
    const memo = document.getElementById('memo');
    const undoBtn = document.getElementById('undo');
    const redoBtn = document.getElementById('redo');
    const clearBtn = document.getElementById('clear');
    const copyBtn = document.getElementById('copy');
    const searchInput = document.getElementById('search');
    const prevBtn = document.getElementById('prev');
    const nextBtn = document.getElementById('next');
    const countSpan = document.getElementById('count');
    const execJsBtn = document.getElementById('exec-js');
    const execHtmlBtn = document.getElementById('exec-html');
    const execBmBtn = document.getElementById('exec-bm');
    const openUrlBtn = document.getElementById('open-url');
    const transformBtn = document.getElementById('transform');
    const transformWindow = document.getElementById('transform-window');
    const closeTransform = document.getElementById('close-transform');
    const convertButton = document.getElementById('convertButton');
    const customMapping = document.getElementById('customMapping');
    const customFrom = document.getElementById('customFrom');
    const customTo = document.getElementById('customTo');
    const prefixInput = document.getElementById('prefix');
    const suffixInput = document.getElementById('suffix');
    const addPrefixSuffixBtn = document.getElementById('add-prefix-suffix');
    const downloadBtn = document.getElementById('download-btn');
    const downloadWindow = document.getElementById('download-window');
    const closeDownload = document.getElementById('close-download');
    const saveFileBtn = document.getElementById('save-file');
    const filenameInput = document.getElementById('filename');
    const extensionInput = document.getElementById('extension');

    // 新機能: 分割コピー
    const splitCopyContainer = document.getElementById('splitCopyContainer');
    const splitSizeInput = document.getElementById('splitSize');
    const splitButtons = document.getElementById('splitButtons');

    // GitHub/同期
    const githubImportContainer = document.getElementById('githubImportContainer');
    const importGithubBtn = document.getElementById('importGithubBtn');
    const githubUrlInput = document.getElementById('githubUrl');
    const syncContainer = document.getElementById('syncContainer');
    const syncBtn = document.getElementById('syncBtn');
    const syncWordInput = document.getElementById('syncWord');
    const syncSendCheckbox = document.getElementById('syncSend');
    const syncReceiveCheckbox = document.getElementById('syncReceive');

    // 文字数カウンタ
    const charCountBtn = document.getElementById('char-count-btn');
    const charCountMenu = document.getElementById('char-count-menu');
    let countMode = 'default';

    // 「明示的な改行があるか」のフラグ（Enter/貼り付けでのみ立てる）
    let hasExplicitBreaks = false;

    // ====== 共通ユーティリティ ======
    function escapeHTML(s) {
      return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    // 見た目が空の contenteditable で発生する "\n" を 0 カウントに正規化
    function _isVisuallyEmptyMemo() {
      const html = memo.innerHTML.replace(/\s|&nbsp;/g, '').toLowerCase();
      return html === '' || html === '<br>' || html === '<div><br></div>' || html === '<p><br></p>';
    }

    // 末尾に明示的な改行（<br> 等）があるか
    function hasExplicitTrailingBreak() {
      const last = memo.lastChild;
      if (!last) return false;
      if (last.nodeName === 'BR') return true;
      if (last.nodeType === 1) {
        const html = (last.innerHTML || '').trim().toLowerCase();
        if (html.endsWith('<br>')) return true;
        const lc = last.lastChild;
        if (lc && lc.nodeName === 'BR') return true;
      }
      return false;
    }

    // カウント用正規化：
    //  - 明示的な改行がなければ \n を全除外（ブラウザ由来の改行ノイズを消す）
    //  - 明示的な改行があるときは末尾の暗黙改行だけ除去
    function normalizeForCount(s) {
      if (!s) return '';
      if (!hasExplicitBreaks) {
        return s.replace(/\n/g, '');
      } else {
        // 末尾の暗黙改行はカウントしない
        if (/\n+$/.test(s) && !hasExplicitTrailingBreak()) {
          s = s.replace(/\n+$/, '');
        }
        return s;
      }
    }

    function getMemoTextForCount() {
      if (_isVisuallyEmptyMemo()) return '';
      return normalizeForCount(memo.innerText);
    }

    function clearHighlights() {
      memo.innerText = rawText;
      matches = [];
      currentIndex = 0;
      countSpan.innerText = '0/0';
    }

    function isNodeInsideMemo(node) {
      return node && (node === memo || memo.contains(node));
    }

    function getSelectedTextInMemo() {
      const sel = window.getSelection();
      if (!sel || !sel.rangeCount) return null;
      const range = sel.getRangeAt(0);
      if (range.collapsed) return null;
      if (isNodeInsideMemo(range.startContainer) && isNodeInsideMemo(range.endContainer)) {
        return sel.toString();
      }
      return null;
    }

    // contenteditable内の絶対オフセットで範囲選択
    function selectMemoRangeByIndex(start, end) {
      clearHighlights();
      const walker = document.createTreeWalker(memo, NodeFilter.SHOW_TEXT, null);
      let cur = 0, startNode=null, startOffset=0, endNode=null, endOffset=0;
      while (true) {
        const node = walker.nextNode();
        if (!node) break;
        const len = node.nodeValue.length;
        if (start >= cur && start <= cur + len) {
          startNode = node;
          startOffset = start - cur;
        }
        if (end >= cur && end <= cur + len) {
          endNode = node;
          endOffset = end - cur;
          break;
        }
        cur += len;
      }
      if (startNode && endNode) {
        const range = document.createRange();
        range.setStart(startNode, startOffset);
        range.setEnd(endNode, endOffset);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
        const rect = range.getBoundingClientRect();
        if (rect && rect.top) window.scrollBy({ top: rect.top - (window.innerHeight/2), behavior: 'smooth' });
        return true;
      }
      return false;
    }

    async function copyText(text) {
      try { await navigator.clipboard.writeText(text); }
      catch {
        const ta = document.createElement('textarea');
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
      }
    }

    // ====== 文字数カウント ======
    function countDefault(str) {
      let n = 0;
      for (const _ch of str) n++;  // code pointベース
      return n;
    }
    function isHalfwidth(ch) {
      if (/[\u0000-\u007F]/.test(ch)) return true;      // ASCII（改行含む）
      if (/[\uFF61-\uFF9F]/.test(ch)) return true;      // 半角カナ
      return false;
    }
    function countXPost(str) {
      let total = 0;
      for (const ch of str) total += isHalfwidth(ch) ? 1 : 2;
      return total;
    }
    function currentCountTargetText() {
      const selText = getSelectedTextInMemo();
      const base = selText != null ? selText : memo.innerText;
      return normalizeForCount(base);
    }
    function updateCharCount() {
      const text = currentCountTargetText();
      const n = (countMode === 'xpost') ? countXPost(text) : countDefault(text);
      charCountBtn.textContent = String(n);
    }
    function showCountMenuNearButton() {
      const rect = charCountBtn.getBoundingClientRect();
      charCountMenu.style.left = `${Math.round(rect.left)}px`;
      charCountMenu.style.top = `${Math.round(rect.bottom + 6)}px`;
      charCountMenu.style.display = 'block';
    }

    document.addEventListener('selectionchange', () => updateCharCount());

    // ====== メモ入力と履歴 ======
    let rawText = getMemoTextForCount();
    let matches = [];
    let currentIndex = 0;
    let history = [rawText];
    let currentStep = 0;

    // Enter/改行の明示入力を検出
    memo.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') hasExplicitBreaks = true;
    });
    memo.addEventListener('beforeinput', (e) => {
      if (e.inputType === 'insertParagraph' || e.inputType === 'insertLineBreak') {
        hasExplicitBreaks = true;
      }
    });

    memo.addEventListener('input', () => {
      const newText = getMemoTextForCount();
      if (newText !== history[currentStep]) {
        history = history.slice(0, currentStep + 1);
        history.push(newText);
        currentStep++;
      }
      rawText = newText;
      // 全消去で改行フラグをリセット
      if (rawText === '') hasExplicitBreaks = false;
      countSpan.innerText = '0/0';
      updateCharCount();
    });

    memo.addEventListener('paste', (e) => {
      e.preventDefault();
      const text = e.clipboardData.getData('text/plain');
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      const range = selection.getRangeAt(0);
      range.deleteContents();
      range.insertNode(document.createTextNode(text));
      // 貼り付けで明示改行が含まれていればカウント対象化
      if (/\r?\n/.test(text)) hasExplicitBreaks = true;

      rawText = getMemoTextForCount();
      history = history.slice(0, currentStep + 1);
      history.push(rawText);
      currentStep++;
      updateCharCount();
    });

    // Undo
    undoBtn.addEventListener('click', () => {
      if (currentStep > 0) {
        currentStep--;
        const state = history[currentStep];
        memo.innerText = state;
        rawText = getMemoTextForCount();
        // 履歴適用時は内容を見てフラグ推定
        hasExplicitBreaks = /\n/.test(memo.innerText) && !_isVisuallyEmptyMemo();
        clearHighlights();
        updateCharCount();
      }
    });

    // Redo
    redoBtn.addEventListener('click', () => {
      if (currentStep < history.length - 1) {
        currentStep++;
        const state = history[currentStep];
        memo.innerText = state;
        rawText = getMemoTextForCount();
        hasExplicitBreaks = /\n/.test(memo.innerText) && !_isVisuallyEmptyMemo();
        clearHighlights();
        updateCharCount();
      }
    });

    // クリア
    clearBtn.addEventListener('click', () => {
      history = [''];
      currentStep = 0;
      rawText = '';
      memo.innerText = '';
      hasExplicitBreaks = false;  // ← リセット
      clearHighlights();
      updateCharCount();
    });

    // コピー（全文）
    copyBtn.addEventListener('click', () => copyText(rawText));

    // 検索ハイライト
    function highlightSearch() {
      clearHighlights();
      const term = searchInput.value.trim();
      if (!term) return;
      const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const regex = new RegExp(escapedTerm, 'gi');
      const escaped = escapeHTML(rawText);
      const highlighted = escaped.replace(regex, match => `<span class="highlight">${match}</span>`);
      memo.innerHTML = highlighted;
      matches = Array.from(memo.querySelectorAll('.highlight'));
      if (matches.length) {
        currentIndex = 0;
        matches[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
        countSpan.innerText = `${currentIndex + 1}/${matches.length}`;
      }
    }
    searchInput.addEventListener('input', highlightSearch);
    prevBtn.addEventListener('click', () => {
      if (!matches.length) return;
      currentIndex = (currentIndex - 1 + matches.length) % matches.length;
      matches[currentIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
      countSpan.innerText = `${currentIndex + 1}/${matches.length}`;
    });
    nextBtn.addEventListener('click', () => {
      if (!matches.length) return;
      currentIndex = (currentIndex + 1) % matches.length;
      matches[currentIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
      countSpan.innerText = `${currentIndex + 1}/${matches.length}`;
    });

    // JS実行
    execJsBtn.addEventListener('click', () => {
      let code = '';
      const sel = window.getSelection();
      if (sel.rangeCount && memo.contains(sel.anchorNode)) code = sel.toString();
      if (!code) code = rawText;
      try {
        const result = new Function(code)();
        if (result !== undefined) alert(result);
      } catch (e) {
        alert('Error: ' + e);
      }
    });

    // HTML実行
    execHtmlBtn.addEventListener('click', () => {
      let html = '';
      const sel = window.getSelection();
      if (sel.rangeCount && memo.contains(sel.anchorNode)) html = sel.toString();
      if (!html) html = rawText;
      const w = window.open();
      w.document.open();
      w.document.write(html);
      w.document.close();
    });

    // ▽（ブックマークレット）
    execBmBtn.addEventListener('click', () => {
      javascript:(function(){/* 必要なら元の処理に差し替えてください */})();
    });

    // 新しいタブで開く
    openUrlBtn.addEventListener('click', () => window.open(location.href, '_blank'));

    // 行頭/行末 追加
    addPrefixSuffixBtn.addEventListener('click', () => {
      const sel = window.getSelection();
      if (!sel.rangeCount || !memo.contains(sel.anchorNode)) return;
      const range = sel.getRangeAt(0);
      const selectedText = sel.toString();
      if (!selectedText) return;
      const prefix = (prefixInput.value ?? '');
      const suffix = (suffixInput.value ?? '');
      const lines = selectedText.split('\n');
      const modified = lines.map(line => prefix + line + suffix).join('\n');
      range.deleteContents();
      range.insertNode(document.createTextNode(modified));
      rawText = getMemoTextForCount();
      hasExplicitBreaks = /\n/.test(memo.innerText) && !_isVisuallyEmptyMemo();
      history = history.slice(0, currentStep + 1);
      history.push(rawText);
      currentStep++;
      updateCharCount();
    });

    // ダウンロード
    downloadBtn.addEventListener('click', () => downloadWindow.style.display = 'block');
    closeDownload.addEventListener('click', () => downloadWindow.style.display = 'none');
    saveFileBtn.addEventListener('click', () => {
      const name = filenameInput.value.trim();
      const ext = extensionInput.value.trim().replace(/^\./, '');
      if (!name || !ext) return alert('ファイル名と拡張子を入力してください');
      const blob = new Blob([getMemoTextForCount()], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${name}.${ext}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      downloadWindow.style.display = 'none';
    });

    // ★パネルの表示/非表示
    transformBtn.addEventListener('click', () => transformWindow.style.display = 'block');
    closeTransform.addEventListener('click', () => transformWindow.style.display = 'none');

    // ラジオ切替（UI表示）
    document.querySelectorAll('#transform-window input[name="action"]').forEach(radio => {
      radio.addEventListener('change', () => {
        const v = document.querySelector('#transform-window input[name="action"]:checked').value;

        customMapping.style.display = (v === 'custom') ? 'block' : 'none';
        githubImportContainer.style.display = (v === 'github_import') ? 'block' : 'none';
        splitCopyContainer.style.display = (v === 'split_copy') ? 'block' : 'none';
        syncContainer.style.display = (v === 'sync') ? 'block' : 'none';

        const hideConvert = (v === 'github_import' || v === 'sync' || v === 'split_copy');
        convertButton.style.display = hideConvert ? 'none' : 'inline-block';

        if (v === 'split_copy') generateSplitButtons();
      });
    });

    // 変換処理
    convertButton.addEventListener('click', () => {
      const action = document.querySelector('#transform-window input[name="action"]:checked').value;

      // PC表示
      if (action === 'pc_view') {
        const C='width=1200, initial-scale=0.4';
        const a=[...document.querySelectorAll('meta[name="viewport" i]')];
        if(a.length){a.forEach((m,i)=>i?m.remove():m.setAttribute('content',C));}
        else{const m=document.createElement('meta');m.name='viewport';m.content=C;(document.head||document.documentElement).prepend(m);}
        transformWindow.style.display = 'none';
        return;
      }

      const sel = window.getSelection();
      let text = '';
      let isSelection = false;

      if (sel.rangeCount && memo.contains(sel.anchorNode) && sel.toString().length > 0) {
        text = sel.toString();
        isSelection = true;
      } else {
        text = memo.innerText;
      }

      let result = '';
      if (action === 'encode') {
        result = encodeURIComponent(text);
      } else if (action === 'decode') {
        try { result = decodeURIComponent(text); }
        catch(e) { alert("デコードエラー: " + e.message); return; }
      } else if (action === 'remove' || action === 'remove1') {
        let lines = text.split('\n').map(line => {
          let idx = line.indexOf('//');
          while (idx !== -1) {
            if (idx >= 6 && line.substring(idx - 6, idx) === "https:") {
              idx = line.indexOf('//', idx + 2);
            } else { break; }
          }
          return idx !== -1 ? line.slice(0, idx) : line;
        });
        result = (action === 'remove1') ? lines.join('') : lines.join('\n');
      } else if (action === 'custom') {
        const from = customFrom.value; // 先頭末尾の空白は保持
        const to = customTo.value;
        if (from === '') {
          if (to === '') alert('変換元と変換先が空欄です。処理は行いません。');
          else alert('変換元が空欄のため、処理は行いません。変換先が空欄のときは削除として機能します。');
          return;
        }
        result = text.split(from).join(to);
      }

      if (isSelection) {
        const range = sel.getRangeAt(0);
        range.deleteContents();
        range.insertNode(document.createTextNode(result));
      } else {
        memo.innerText = result;
      }

      rawText = getMemoTextForCount();
      hasExplicitBreaks = /\n/.test(memo.innerText) && !_isVisuallyEmptyMemo();
      history.push(rawText);
      currentStep = history.length - 1;
      transformWindow.style.display = 'none';
      updateCharCount();
    });

    // ====== GitHubインポート ======
    importGithubBtn.addEventListener('click', async () => {
      let url = githubUrlInput.value.trim();
      if (!url) return alert('GitHubのURLを入力してください。');
      if (url.includes('github.com') && !url.includes('raw.githubusercontent.com')) {
        url = url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
      }
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.text();
        memo.innerText = data;
        rawText = getMemoTextForCount();
        hasExplicitBreaks = /\n/.test(memo.innerText) && !_isVisuallyEmptyMemo();
        history.push(rawText);
        currentStep = history.length - 1;
        transformWindow.style.display = 'none';
        alert('インポートが完了しました。');
        updateCharCount();
      } catch (error) {
        alert('インポートに失敗しました: ' + error.message);
      }
    });

    // ====== 分割コピー ======
    function generateSplitButtons() {
      clearHighlights();
      splitButtons.innerHTML = '';
      const size = Math.max(1, parseInt(splitSizeInput.value || '19000', 10));
      const text = rawText;
      const total = text.length;

      let idx = 0, chunkIndex = 0;
      while (idx < total) {
        const start = idx;
        const end = Math.min(idx + size, total);
        const chunk = text.slice(start, end);
        const first5 = chunk.slice(0, 5);
        const last5  = chunk.slice(Math.max(0, chunk.length - 5));
        const btn = document.createElement('button');
        btn.textContent = `${first5}～${last5}`;
        btn.title = `#${chunkIndex+1} (${start}..${end})`;
        btn.addEventListener('click', async () => {
          selectMemoRangeByIndex(start, end);
          await copyText(chunk);
        });
        splitButtons.appendChild(btn);
        idx = end;
        chunkIndex++;
      }
      if (chunkIndex === 0) {
        const muted = document.createElement('div');
        muted.className = 'muted';
        muted.textContent = 'メモが空です。';
        splitButtons.appendChild(muted);
      }
    }
    splitSizeInput.addEventListener('input', () => {
      const action = document.querySelector('#transform-window input[name="action"]:checked').value;
      if (action === 'split_copy') generateSplitButtons();
    });

    // ====== 同期 ======
    syncBtn.addEventListener('click', () => {
      const syncWord = syncWordInput.value.trim();
      const isSending = syncSendCheckbox.checked;
      const isReceiving = syncReceiveCheckbox.checked;

      if (!syncWord) return alert('同期ワードを入力してください。');
      if (!isSending && !isReceiving) return alert('送信または受信のどちらかを選択してください。');
      if (isSending && isReceiving) return alert('送信と受信を同時に選択することはできません。');

      const topic = 'memo-tool-sync-v2/' + syncWord;
      const client = mqtt.connect('wss://broker.hivemq.com:8884/mqtt');

      client.on('connect', () => {
        if (isSending) {
          client.publish(topic, memo.innerText, { qos: 1 }, (err) => {
            if (err) alert('送信エラー: ' + err);
            else alert('送信しました。');
            client.end();
            transformWindow.style.display = 'none';
          });
        } else if (isReceiving) {
          client.subscribe(topic, (err) => {
            if (err) { alert('受信準備エラー: ' + err); client.end(); }
            else { alert('受信待機中です。送信側で同期ボタンを押してください。'); }
          });
        }
      });

      client.on('message', (receivedTopic, message) => {
        if (receivedTopic === topic && isReceiving) {
          const newText = message.toString();
          memo.innerText = newText;
          rawText = getMemoTextForCount();
          hasExplicitBreaks = /\n/.test(memo.innerText) && !_isVisuallyEmptyMemo();
          history.push(rawText);
          currentStep = history.length - 1;
          alert('受信しました。');
          client.end();
          transformWindow.style.display = 'none';
          updateCharCount();
        }
      });

      client.on('error', (err) => {
        alert('同期接続エラー: ' + err.message);
        client.end();
      });
    });

    // ====== 文字数ボタンのUI ======
    charCountBtn.addEventListener('click', () => {
      if (charCountMenu.style.display === 'block') {
        charCountMenu.style.display = 'none';
      } else {
        showCountMenuNearButton();
      }
    });
    charCountMenu.addEventListener('change', (e) => {
      if (e.target.name === 'countMode') {
        countMode = e.target.value;
        updateCharCount();
        charCountMenu.style.display = 'none';
      }
    });
    document.addEventListener('click', (e) => {
      if (e.target !== charCountBtn && !charCountMenu.contains(e.target)) {
        charCountMenu.style.display = 'none';
      }
    }, true);

    // ====== 初期化：常にデフォルトモードに戻す ======
    (function initCountMode() {
      countMode = 'default';
      const defaultRadio = document.querySelector('input[name="countMode"][value="default"]');
      if (defaultRadio) defaultRadio.checked = true;
      // 初期状態では明示改行なし
      hasExplicitBreaks = false;
      updateCharCount();
    })();

  </script>
</body>
</html>
