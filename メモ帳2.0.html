<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ãƒ¡ãƒ¢ãƒ„ãƒ¼ãƒ«</title>
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <style>
    html, body { height: 100%; margin: 0; padding: 18px; box-sizing: border-box; }
    body { display: flex; flex-direction: column; font-family: sans-serif; }
    .controls { flex: 0 0 auto; margin-bottom: 10px; position: relative; }
    .controls button, .controls input {
      margin-right: 5px;
      padding: 7px 7px;
      font-size: 12px;
    }
    #memo {
      flex: 1 1 auto;
      width: 100%;
      border: 1px solid #ccc;
      padding: 10px;
      overflow: auto;
      white-space: pre-wrap;
      font-family: monospace;
    }
    .highlight { background-color: yellow; }
    #transform-window {
      display: none;
      position: fixed;
      top: 15%;
      left: 50%;
      transform: translateX(-50%);
      background: #fff;
      border: 1px solid #ccc;
      padding: 20px;
      z-index: 1000;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
      max-height: 70vh;
      overflow-y: auto;
      width: min(400px, 92vw);
    }
    #transform-window label {
      display: block;
      margin: 10px 0 5px;
    }
    #transform-window input[type="text"], #transform-window input[type="number"] {
      width: 100%;
      padding: 5px;
      margin-bottom: 10px;
      box-sizing: border-box;
      font-family: monospace;
    }
    #transform-window button {
      padding: 5px 10px;
      margin-right: 5px;
    }
    #close-transform {
      position: absolute;
      top: 5px;
      right: 5px;
      cursor: pointer;
      font-weight: bold;
    }
    #download-window {
      display: none;
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      background: #fff;
      border: 1px solid #ccc;
      padding: 20px;
      z-index: 1000;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
    }
    #close-download { float: right; }

    .feature-container {
      border-top: 1px solid #eee;
      padding-top: 10px;
      margin-top: 10px;
    }

    /* æ–‡å­—æ•°ãƒœã‚¿ãƒ³ã¨ãƒ¡ãƒ‹ãƒ¥ãƒ¼ */
    #char-count-btn {
      min-width: 3.5em;
      font-variant-numeric: tabular-nums;
    }
    #char-count-menu {
      position: fixed;
      display: none;
      background: #fff;
      border: 1px solid #ccc;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
      padding: 8px 10px;
      z-index: 1200;
      font-size: 12px;
      line-height: 1.6;
    }
    #char-count-menu label { display: block; cursor: pointer; }
    #splitButtons { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 6px; }
    #splitButtons button { text-align: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .muted { color: #777; font-size: 11px; }
  </style>
</head>
<body>
  <div class="controls">
    <button id="undo">â†</button>
    <button id="redo">â†’</button>
    <button id="clear">ã‚¯ãƒªã‚¢</button>
    <button id="copy">ã‚³ãƒ”ãƒ¼</button>
    <input id="search" type="text" placeholder="ğŸ” ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œç´¢">
    <button id="prev"><</button>
    <span id="count">0/0</span>
    <button id="next">></button>
    <input id="prefix" type="text" placeholder="å§‹ã‚">
    <input id="suffix" type="text" placeholder="çµ‚ã‚ã‚Š">
    <button id="add-prefix-suffix">è¿½åŠ </button>
    <button id="exec-js">JavaScriptã‚’å®Ÿè¡Œ</button>
    <button id="exec-html">HTMLã‚’å®Ÿè¡Œ</button>
    <button id="exec-bm">â–½</button>
    <button id="transform">â˜…</button> <button id="open-url">ï¼‹</button>
    <button id="download-btn">ğŸ–¥ï¸</button>
    <!-- æ–‡å­—æ•°ã‚«ã‚¦ãƒ³ã‚¿ -->
    <button id="char-count-btn" title="æ–‡å­—æ•°">0</button>
    <div id="char-count-menu">
      <strong>ã‚«ã‚¦ãƒ³ãƒˆãƒ¢ãƒ¼ãƒ‰</strong>
      <label><input type="radio" name="countMode" value="default" checked> ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼ˆå…¨ã¦=1ï¼‰</label>
      <label><input type="radio" name="countMode" value="xpost"> Xãƒã‚¹ãƒˆç”¨ï¼ˆåŠè§’=1 / å…¨è§’=2ï¼‰</label>
      <div class="muted">â€» ç¯„å›²é¸æŠä¸­ã¯é¸æŠéƒ¨åˆ†ã‚’ã‚«ã‚¦ãƒ³ãƒˆ</div>
    </div>

    <div id="download-window">
      <button id="close-download">â˜’</button>
      <div>
        <label>ãƒ•ã‚¡ã‚¤ãƒ«å</label><br>
        <input id="filename" type="text" placeholder="example"><br><br>
        <label>æ‹¡å¼µå­</label><br>
        <input id="extension" type="text" placeholder="txt"><br><br>
        <button id="save-file">ä¿å­˜</button>
      </div>
    </div>

    <div id="transform-window">
      <div id="close-transform">â˜’</div>

      <label><input type="radio" name="action" value="encode" checked> ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰</label>
      <label><input type="radio" name="action" value="decode"> ãƒ‡ã‚³ãƒ¼ãƒ‰</label>
      <label><input type="radio" name="action" value="remove"> ã‚³ãƒ¡ãƒ³ãƒˆå‰Šé™¤</label>
      <label><input type="radio" name="action" value="remove1"> ã‚³ãƒ¡ãƒ³ãƒˆå‰Šé™¤(1æ–‡)</label>
      <label><input type="radio" name="action" value="custom"> ã‚«ã‚¹ã‚¿ãƒ </label>
      <label><input type="radio" name="action" value="pc_view"> PCè¡¨ç¤º</label>
      <label><input type="radio" name="action" value="github_import"> GitHubã‚¤ãƒ³ãƒãƒ¼ãƒˆ</label>
      <!-- â˜… åˆ†å‰²ã‚³ãƒ”ãƒ¼ï¼ˆGitHubã‚¤ãƒ³ãƒãƒ¼ãƒˆã¨åŒæœŸã®é–“ï¼‰ -->
      <label><input type="radio" name="action" value="split_copy"> åˆ†å‰²ã‚³ãƒ”ãƒ¼</label>
      <label><input type="radio" name="action" value="sync"> åŒæœŸ</label>

      <!-- ã‚«ã‚¹ã‚¿ãƒ å¤‰æ› -->
      <div id="customMapping" class="feature-container" style="display: none;">
        <label for="customFrom">ã‚«ã‚¹ã‚¿ãƒ å¤‰æ› (å¤‰æ›å…ƒ â†’ å¤‰æ›å…ˆ)</label>
        <input type="text" id="customFrom" placeholder="å¤‰æ›å…ƒï¼ˆç©ºç™½ã‚‚å¯ï¼‰">
        <input type="text" id="customTo" placeholder="å¤‰æ›å…ˆï¼ˆç©ºæ¬„ã§å‰Šé™¤ / ç©ºç™½ã‚‚å¯ï¼‰">
        <div class="muted">â€» å¤‰æ›å…ƒãŒ<span style="text-decoration:underline;">ç©ºæ¬„</span>ã®ã¨ãã¯å¤‰æ›ã—ã¾ã›ã‚“ï¼ˆå®‰å…¨ï¼‰ã€‚å¤‰æ›å…ˆãŒç©ºæ¬„ãªã‚‰å‰Šé™¤ã¨ã—ã¦æ©Ÿèƒ½ã—ã¾ã™ã€‚</div>
      </div>

      <!-- GitHubã‚¤ãƒ³ãƒãƒ¼ãƒˆ -->
      <div id="githubImportContainer" class="feature-container" style="display: none;">
        <label for="githubUrl">GitHubã®URL</label>
        <input type="text" id="githubUrl" placeholder="ãƒªãƒã‚¸ãƒˆãƒª or Raw URL">
        <button id="importGithubBtn">ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
      </div>

      <!-- åˆ†å‰²ã‚³ãƒ”ãƒ¼ -->
      <div id="splitCopyContainer" class="feature-container" style="display: none;">
        <label for="splitSize">åˆ†å‰²ã‚µã‚¤ã‚ºï¼ˆæ–‡å­—æ•°ï¼‰</label>
        <input type="number" id="splitSize" min="1" value="19000">
        <div id="splitButtons"></div>
      </div>

      <!-- åŒæœŸ -->
      <div id="syncContainer" class="feature-container" style="display: none;">
        <label for="syncWord">åŒæœŸãƒ¯ãƒ¼ãƒ‰</label>
        <input type="text" id="syncWord" placeholder="ç§˜å¯†ã®è¨€è‘‰">
        <label><input type="checkbox" id="syncSend"> é€ä¿¡</label>
        <label><input type="checkbox" id="syncReceive"> å—ä¿¡</label>
        <button id="syncBtn">åŒæœŸ</button>
      </div>

      <button id="convertButton" style="margin-top: 15px;">å¤‰æ›</button>
    </div>
  </div>

  <div id="memo" contenteditable="true"></div>

  <script>
    const memo = document.getElementById('memo');
    const undoBtn = document.getElementById('undo');
    const redoBtn = document.getElementById('redo');
    const clearBtn = document.getElementById('clear');
    const copyBtn = document.getElementById('copy');
    const searchInput = document.getElementById('search');
    const prevBtn = document.getElementById('prev');
    const nextBtn = document.getElementById('next');
    const countSpan = document.getElementById('count');
    const execJsBtn = document.getElementById('exec-js');
    const execHtmlBtn = document.getElementById('exec-html');
    const execBmBtn = document.getElementById('exec-bm');
    const openUrlBtn = document.getElementById('open-url');
    const transformBtn = document.getElementById('transform');
    const transformWindow = document.getElementById('transform-window');
    const closeTransform = document.getElementById('close-transform');
    const convertButton = document.getElementById('convertButton');
    const customMapping = document.getElementById('customMapping');
    const customFrom = document.getElementById('customFrom');
    const customTo = document.getElementById('customTo');
    const prefixInput = document.getElementById('prefix');
    const suffixInput = document.getElementById('suffix');
    const addPrefixSuffixBtn = document.getElementById('add-prefix-suffix');
    const downloadBtn = document.getElementById('download-btn');
    const downloadWindow = document.getElementById('download-window');
    const closeDownload = document.getElementById('close-download');
    const saveFileBtn = document.getElementById('save-file');
    const filenameInput = document.getElementById('filename');
    const extensionInput = document.getElementById('extension');

    // æ–°æ©Ÿèƒ½: åˆ†å‰²ã‚³ãƒ”ãƒ¼
    const splitCopyContainer = document.getElementById('splitCopyContainer');
    const splitSizeInput = document.getElementById('splitSize');
    const splitButtons = document.getElementById('splitButtons');

    // GitHub/åŒæœŸ
    const githubImportContainer = document.getElementById('githubImportContainer');
    const importGithubBtn = document.getElementById('importGithubBtn');
    const githubUrlInput = document.getElementById('githubUrl');
    const syncContainer = document.getElementById('syncContainer');
    const syncBtn = document.getElementById('syncBtn');
    const syncWordInput = document.getElementById('syncWord');
    const syncSendCheckbox = document.getElementById('syncSend');
    const syncReceiveCheckbox = document.getElementById('syncReceive');

    // æ–‡å­—æ•°ã‚«ã‚¦ãƒ³ã‚¿
    const charCountBtn = document.getElementById('char-count-btn');
    const charCountMenu = document.getElementById('char-count-menu');
    let countMode = 'default';

    // ã€Œæ˜ç¤ºçš„ãªæ”¹è¡ŒãŒã‚ã‚‹ã‹ã€ã®ãƒ•ãƒ©ã‚°ï¼ˆEnter/è²¼ã‚Šä»˜ã‘ã§ã®ã¿ç«‹ã¦ã‚‹ï¼‰
    let hasExplicitBreaks = false;

    // ====== å…±é€šãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ======
    function escapeHTML(s) {
      return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    // è¦‹ãŸç›®ãŒç©ºã® contenteditable ã§ç™ºç”Ÿã™ã‚‹ "\n" ã‚’ 0 ã‚«ã‚¦ãƒ³ãƒˆã«æ­£è¦åŒ–
    function _isVisuallyEmptyMemo() {
      const html = memo.innerHTML.replace(/\s|&nbsp;/g, '').toLowerCase();
      return html === '' || html === '<br>' || html === '<div><br></div>' || html === '<p><br></p>';
    }

    // æœ«å°¾ã«æ˜ç¤ºçš„ãªæ”¹è¡Œï¼ˆ<br> ç­‰ï¼‰ãŒã‚ã‚‹ã‹
    function hasExplicitTrailingBreak() {
      const last = memo.lastChild;
      if (!last) return false;
      if (last.nodeName === 'BR') return true;
      if (last.nodeType === 1) {
        const html = (last.innerHTML || '').trim().toLowerCase();
        if (html.endsWith('<br>')) return true;
        const lc = last.lastChild;
        if (lc && lc.nodeName === 'BR') return true;
      }
      return false;
    }

    // ã‚«ã‚¦ãƒ³ãƒˆç”¨æ­£è¦åŒ–ï¼š
    //  - æ˜ç¤ºçš„ãªæ”¹è¡ŒãŒãªã‘ã‚Œã° \n ã‚’å…¨é™¤å¤–ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ç”±æ¥ã®æ”¹è¡Œãƒã‚¤ã‚ºã‚’æ¶ˆã™ï¼‰
    //  - æ˜ç¤ºçš„ãªæ”¹è¡ŒãŒã‚ã‚‹ã¨ãã¯æœ«å°¾ã®æš—é»™æ”¹è¡Œã ã‘é™¤å»
    function normalizeForCount(s) {
      if (!s) return '';
      if (!hasExplicitBreaks) {
        return s.replace(/\n/g, '');
      } else {
        // æœ«å°¾ã®æš—é»™æ”¹è¡Œã¯ã‚«ã‚¦ãƒ³ãƒˆã—ãªã„
        if (/\n+$/.test(s) && !hasExplicitTrailingBreak()) {
          s = s.replace(/\n+$/, '');
        }
        return s;
      }
    }

    function getMemoTextForCount() {
      if (_isVisuallyEmptyMemo()) return '';
      return normalizeForCount(memo.innerText);
    }

    function clearHighlights() {
      memo.innerText = rawText;
      matches = [];
      currentIndex = 0;
      countSpan.innerText = '0/0';
    }

    function isNodeInsideMemo(node) {
      return node && (node === memo || memo.contains(node));
    }

    function getSelectedTextInMemo() {
      const sel = window.getSelection();
      if (!sel || !sel.rangeCount) return null;
      const range = sel.getRangeAt(0);
      if (range.collapsed) return null;
      if (isNodeInsideMemo(range.startContainer) && isNodeInsideMemo(range.endContainer)) {
        return sel.toString();
      }
      return null;
    }

    // contenteditableå†…ã®çµ¶å¯¾ã‚ªãƒ•ã‚»ãƒƒãƒˆã§ç¯„å›²é¸æŠ
    function selectMemoRangeByIndex(start, end) {
      clearHighlights();
      const walker = document.createTreeWalker(memo, NodeFilter.SHOW_TEXT, null);
      let cur = 0, startNode=null, startOffset=0, endNode=null, endOffset=0;
      while (true) {
        const node = walker.nextNode();
        if (!node) break;
        const len = node.nodeValue.length;
        if (start >= cur && start <= cur + len) {
          startNode = node;
          startOffset = start - cur;
        }
        if (end >= cur && end <= cur + len) {
          endNode = node;
          endOffset = end - cur;
          break;
        }
        cur += len;
      }
      if (startNode && endNode) {
        const range = document.createRange();
        range.setStart(startNode, startOffset);
        range.setEnd(endNode, endOffset);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
        const rect = range.getBoundingClientRect();
        if (rect && rect.top) window.scrollBy({ top: rect.top - (window.innerHeight/2), behavior: 'smooth' });
        return true;
      }
      return false;
    }

    async function copyText(text) {
      try { await navigator.clipboard.writeText(text); }
      catch {
        const ta = document.createElement('textarea');
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
      }
    }

    // ====== æ–‡å­—æ•°ã‚«ã‚¦ãƒ³ãƒˆ ======
    function countDefault(str) {
      let n = 0;
      for (const _ch of str) n++;  // code pointãƒ™ãƒ¼ã‚¹
      return n;
    }
    function isHalfwidth(ch) {
      if (/[\u0000-\u007F]/.test(ch)) return true;      // ASCIIï¼ˆæ”¹è¡Œå«ã‚€ï¼‰
      if (/[\uFF61-\uFF9F]/.test(ch)) return true;      // åŠè§’ã‚«ãƒŠ
      return false;
    }
    function countXPost(str) {
      let total = 0;
      for (const ch of str) total += isHalfwidth(ch) ? 1 : 2;
      return total;
    }
    function currentCountTargetText() {
      const selText = getSelectedTextInMemo();
      const base = selText != null ? selText : memo.innerText;
      return normalizeForCount(base);
    }
    function updateCharCount() {
      const text = currentCountTargetText();
      const n = (countMode === 'xpost') ? countXPost(text) : countDefault(text);
      charCountBtn.textContent = String(n);
    }
    function showCountMenuNearButton() {
      const rect = charCountBtn.getBoundingClientRect();
      charCountMenu.style.left = `${Math.round(rect.left)}px`;
      charCountMenu.style.top = `${Math.round(rect.bottom + 6)}px`;
      charCountMenu.style.display = 'block';
    }

    document.addEventListener('selectionchange', () => updateCharCount());

    // ====== ãƒ¡ãƒ¢å…¥åŠ›ã¨å±¥æ­´ ======
    let rawText = getMemoTextForCount();
    let matches = [];
    let currentIndex = 0;
    let history = [rawText];
    let currentStep = 0;

    // Enter/æ”¹è¡Œã®æ˜ç¤ºå…¥åŠ›ã‚’æ¤œå‡º
    memo.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') hasExplicitBreaks = true;
    });
    memo.addEventListener('beforeinput', (e) => {
      if (e.inputType === 'insertParagraph' || e.inputType === 'insertLineBreak') {
        hasExplicitBreaks = true;
      }
    });

    memo.addEventListener('input', () => {
      const newText = getMemoTextForCount();
      if (newText !== history[currentStep]) {
        history = history.slice(0, currentStep + 1);
        history.push(newText);
        currentStep++;
      }
      rawText = newText;
      // å…¨æ¶ˆå»ã§æ”¹è¡Œãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
      if (rawText === '') hasExplicitBreaks = false;
      countSpan.innerText = '0/0';
      updateCharCount();
    });

    memo.addEventListener('paste', (e) => {
      e.preventDefault();
      const text = e.clipboardData.getData('text/plain');
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      const range = selection.getRangeAt(0);
      range.deleteContents();
      range.insertNode(document.createTextNode(text));
      // è²¼ã‚Šä»˜ã‘ã§æ˜ç¤ºæ”¹è¡ŒãŒå«ã¾ã‚Œã¦ã„ã‚Œã°ã‚«ã‚¦ãƒ³ãƒˆå¯¾è±¡åŒ–
      if (/\r?\n/.test(text)) hasExplicitBreaks = true;

      rawText = getMemoTextForCount();
      history = history.slice(0, currentStep + 1);
      history.push(rawText);
      currentStep++;
      updateCharCount();
    });

    // Undo
    undoBtn.addEventListener('click', () => {
      if (currentStep > 0) {
        currentStep--;
        const state = history[currentStep];
        memo.innerText = state;
        rawText = getMemoTextForCount();
        // å±¥æ­´é©ç”¨æ™‚ã¯å†…å®¹ã‚’è¦‹ã¦ãƒ•ãƒ©ã‚°æ¨å®š
        hasExplicitBreaks = /\n/.test(memo.innerText) && !_isVisuallyEmptyMemo();
        clearHighlights();
        updateCharCount();
      }
    });

    // Redo
    redoBtn.addEventListener('click', () => {
      if (currentStep < history.length - 1) {
        currentStep++;
        const state = history[currentStep];
        memo.innerText = state;
        rawText = getMemoTextForCount();
        hasExplicitBreaks = /\n/.test(memo.innerText) && !_isVisuallyEmptyMemo();
        clearHighlights();
        updateCharCount();
      }
    });

    // ã‚¯ãƒªã‚¢
    clearBtn.addEventListener('click', () => {
      history = [''];
      currentStep = 0;
      rawText = '';
      memo.innerText = '';
      hasExplicitBreaks = false;  // â† ãƒªã‚»ãƒƒãƒˆ
      clearHighlights();
      updateCharCount();
    });

    // ã‚³ãƒ”ãƒ¼ï¼ˆå…¨æ–‡ï¼‰
    copyBtn.addEventListener('click', () => copyText(rawText));

    // æ¤œç´¢ãƒã‚¤ãƒ©ã‚¤ãƒˆ
    function highlightSearch() {
      clearHighlights();
      const term = searchInput.value.trim();
      if (!term) return;
      const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const regex = new RegExp(escapedTerm, 'gi');
      const escaped = escapeHTML(rawText);
      const highlighted = escaped.replace(regex, match => `<span class="highlight">${match}</span>`);
      memo.innerHTML = highlighted;
      matches = Array.from(memo.querySelectorAll('.highlight'));
      if (matches.length) {
        currentIndex = 0;
        matches[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
        countSpan.innerText = `${currentIndex + 1}/${matches.length}`;
      }
    }
    searchInput.addEventListener('input', highlightSearch);
    prevBtn.addEventListener('click', () => {
      if (!matches.length) return;
      currentIndex = (currentIndex - 1 + matches.length) % matches.length;
      matches[currentIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
      countSpan.innerText = `${currentIndex + 1}/${matches.length}`;
    });
    nextBtn.addEventListener('click', () => {
      if (!matches.length) return;
      currentIndex = (currentIndex + 1) % matches.length;
      matches[currentIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
      countSpan.innerText = `${currentIndex + 1}/${matches.length}`;
    });

    // JSå®Ÿè¡Œ
    execJsBtn.addEventListener('click', () => {
      let code = '';
      const sel = window.getSelection();
      if (sel.rangeCount && memo.contains(sel.anchorNode)) code = sel.toString();
      if (!code) code = rawText;
      try {
        const result = new Function(code)();
        if (result !== undefined) alert(result);
      } catch (e) {
        alert('Error: ' + e);
      }
    });

    // HTMLå®Ÿè¡Œ
    execHtmlBtn.addEventListener('click', () => {
      let html = '';
      const sel = window.getSelection();
      if (sel.rangeCount && memo.contains(sel.anchorNode)) html = sel.toString();
      if (!html) html = rawText;
      const w = window.open();
      w.document.open();
      w.document.write(html);
      w.document.close();
    });

    // â–½ï¼ˆãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆï¼‰
    execBmBtn.addEventListener('click', () => {
      javascript:(function(){/* å¿…è¦ãªã‚‰å…ƒã®å‡¦ç†ã«å·®ã—æ›¿ãˆã¦ãã ã•ã„ */})();
    });

    // æ–°ã—ã„ã‚¿ãƒ–ã§é–‹ã
    openUrlBtn.addEventListener('click', () => window.open(location.href, '_blank'));

    // è¡Œé ­/è¡Œæœ« è¿½åŠ 
    addPrefixSuffixBtn.addEventListener('click', () => {
      const sel = window.getSelection();
      if (!sel.rangeCount || !memo.contains(sel.anchorNode)) return;
      const range = sel.getRangeAt(0);
      const selectedText = sel.toString();
      if (!selectedText) return;
      const prefix = (prefixInput.value ?? '');
      const suffix = (suffixInput.value ?? '');
      const lines = selectedText.split('\n');
      const modified = lines.map(line => prefix + line + suffix).join('\n');
      range.deleteContents();
      range.insertNode(document.createTextNode(modified));
      rawText = getMemoTextForCount();
      hasExplicitBreaks = /\n/.test(memo.innerText) && !_isVisuallyEmptyMemo();
      history = history.slice(0, currentStep + 1);
      history.push(rawText);
      currentStep++;
      updateCharCount();
    });

    // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
    downloadBtn.addEventListener('click', () => downloadWindow.style.display = 'block');
    closeDownload.addEventListener('click', () => downloadWindow.style.display = 'none');
    saveFileBtn.addEventListener('click', () => {
      const name = filenameInput.value.trim();
      const ext = extensionInput.value.trim().replace(/^\./, '');
      if (!name || !ext) return alert('ãƒ•ã‚¡ã‚¤ãƒ«åã¨æ‹¡å¼µå­ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
      const blob = new Blob([getMemoTextForCount()], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${name}.${ext}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      downloadWindow.style.display = 'none';
    });

    // â˜…ãƒ‘ãƒãƒ«ã®è¡¨ç¤º/éè¡¨ç¤º
    transformBtn.addEventListener('click', () => transformWindow.style.display = 'block');
    closeTransform.addEventListener('click', () => transformWindow.style.display = 'none');

    // ãƒ©ã‚¸ã‚ªåˆ‡æ›¿ï¼ˆUIè¡¨ç¤ºï¼‰
    document.querySelectorAll('#transform-window input[name="action"]').forEach(radio => {
      radio.addEventListener('change', () => {
        const v = document.querySelector('#transform-window input[name="action"]:checked').value;

        customMapping.style.display = (v === 'custom') ? 'block' : 'none';
        githubImportContainer.style.display = (v === 'github_import') ? 'block' : 'none';
        splitCopyContainer.style.display = (v === 'split_copy') ? 'block' : 'none';
        syncContainer.style.display = (v === 'sync') ? 'block' : 'none';

        const hideConvert = (v === 'github_import' || v === 'sync' || v === 'split_copy');
        convertButton.style.display = hideConvert ? 'none' : 'inline-block';

        if (v === 'split_copy') generateSplitButtons();
      });
    });

    // å¤‰æ›å‡¦ç†
    convertButton.addEventListener('click', () => {
      const action = document.querySelector('#transform-window input[name="action"]:checked').value;

      // PCè¡¨ç¤º
      if (action === 'pc_view') {
        const C='width=1200, initial-scale=0.4';
        const a=[...document.querySelectorAll('meta[name="viewport" i]')];
        if(a.length){a.forEach((m,i)=>i?m.remove():m.setAttribute('content',C));}
        else{const m=document.createElement('meta');m.name='viewport';m.content=C;(document.head||document.documentElement).prepend(m);}
        transformWindow.style.display = 'none';
        return;
      }

      const sel = window.getSelection();
      let text = '';
      let isSelection = false;

      if (sel.rangeCount && memo.contains(sel.anchorNode) && sel.toString().length > 0) {
        text = sel.toString();
        isSelection = true;
      } else {
        text = memo.innerText;
      }

      let result = '';
      if (action === 'encode') {
        result = encodeURIComponent(text);
      } else if (action === 'decode') {
        try { result = decodeURIComponent(text); }
        catch(e) { alert("ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: " + e.message); return; }
      } else if (action === 'remove' || action === 'remove1') {
        let lines = text.split('\n').map(line => {
          let idx = line.indexOf('//');
          while (idx !== -1) {
            if (idx >= 6 && line.substring(idx - 6, idx) === "https:") {
              idx = line.indexOf('//', idx + 2);
            } else { break; }
          }
          return idx !== -1 ? line.slice(0, idx) : line;
        });
        result = (action === 'remove1') ? lines.join('') : lines.join('\n');
      } else if (action === 'custom') {
        const from = customFrom.value; // å…ˆé ­æœ«å°¾ã®ç©ºç™½ã¯ä¿æŒ
        const to = customTo.value;
        if (from === '') {
          if (to === '') alert('å¤‰æ›å…ƒã¨å¤‰æ›å…ˆãŒç©ºæ¬„ã§ã™ã€‚å‡¦ç†ã¯è¡Œã„ã¾ã›ã‚“ã€‚');
          else alert('å¤‰æ›å…ƒãŒç©ºæ¬„ã®ãŸã‚ã€å‡¦ç†ã¯è¡Œã„ã¾ã›ã‚“ã€‚å¤‰æ›å…ˆãŒç©ºæ¬„ã®ã¨ãã¯å‰Šé™¤ã¨ã—ã¦æ©Ÿèƒ½ã—ã¾ã™ã€‚');
          return;
        }
        result = text.split(from).join(to);
      }

      if (isSelection) {
        const range = sel.getRangeAt(0);
        range.deleteContents();
        range.insertNode(document.createTextNode(result));
      } else {
        memo.innerText = result;
      }

      rawText = getMemoTextForCount();
      hasExplicitBreaks = /\n/.test(memo.innerText) && !_isVisuallyEmptyMemo();
      history.push(rawText);
      currentStep = history.length - 1;
      transformWindow.style.display = 'none';
      updateCharCount();
    });

    // ====== GitHubã‚¤ãƒ³ãƒãƒ¼ãƒˆ ======
    importGithubBtn.addEventListener('click', async () => {
      let url = githubUrlInput.value.trim();
      if (!url) return alert('GitHubã®URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
      if (url.includes('github.com') && !url.includes('raw.githubusercontent.com')) {
        url = url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
      }
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.text();
        memo.innerText = data;
        rawText = getMemoTextForCount();
        hasExplicitBreaks = /\n/.test(memo.innerText) && !_isVisuallyEmptyMemo();
        history.push(rawText);
        currentStep = history.length - 1;
        transformWindow.style.display = 'none';
        alert('ã‚¤ãƒ³ãƒãƒ¼ãƒˆãŒå®Œäº†ã—ã¾ã—ãŸã€‚');
        updateCharCount();
      } catch (error) {
        alert('ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
      }
    });

    // ====== åˆ†å‰²ã‚³ãƒ”ãƒ¼ ======
    function generateSplitButtons() {
      clearHighlights();
      splitButtons.innerHTML = '';
      const size = Math.max(1, parseInt(splitSizeInput.value || '19000', 10));
      const text = rawText;
      const total = text.length;

      let idx = 0, chunkIndex = 0;
      while (idx < total) {
        const start = idx;
        const end = Math.min(idx + size, total);
        const chunk = text.slice(start, end);
        const first5 = chunk.slice(0, 5);
        const last5  = chunk.slice(Math.max(0, chunk.length - 5));
        const btn = document.createElement('button');
        btn.textContent = `${first5}ï½${last5}`;
        btn.title = `#${chunkIndex+1} (${start}..${end})`;
        btn.addEventListener('click', async () => {
          selectMemoRangeByIndex(start, end);
          await copyText(chunk);
        });
        splitButtons.appendChild(btn);
        idx = end;
        chunkIndex++;
      }
      if (chunkIndex === 0) {
        const muted = document.createElement('div');
        muted.className = 'muted';
        muted.textContent = 'ãƒ¡ãƒ¢ãŒç©ºã§ã™ã€‚';
        splitButtons.appendChild(muted);
      }
    }
    splitSizeInput.addEventListener('input', () => {
      const action = document.querySelector('#transform-window input[name="action"]:checked').value;
      if (action === 'split_copy') generateSplitButtons();
    });

    // ====== åŒæœŸ ======
    syncBtn.addEventListener('click', () => {
      const syncWord = syncWordInput.value.trim();
      const isSending = syncSendCheckbox.checked;
      const isReceiving = syncReceiveCheckbox.checked;

      if (!syncWord) return alert('åŒæœŸãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
      if (!isSending && !isReceiving) return alert('é€ä¿¡ã¾ãŸã¯å—ä¿¡ã®ã©ã¡ã‚‰ã‹ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
      if (isSending && isReceiving) return alert('é€ä¿¡ã¨å—ä¿¡ã‚’åŒæ™‚ã«é¸æŠã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚');

      const topic = 'memo-tool-sync-v2/' + syncWord;
      const client = mqtt.connect('wss://broker.hivemq.com:8884/mqtt');

      client.on('connect', () => {
        if (isSending) {
          client.publish(topic, memo.innerText, { qos: 1 }, (err) => {
            if (err) alert('é€ä¿¡ã‚¨ãƒ©ãƒ¼: ' + err);
            else alert('é€ä¿¡ã—ã¾ã—ãŸã€‚');
            client.end();
            transformWindow.style.display = 'none';
          });
        } else if (isReceiving) {
          client.subscribe(topic, (err) => {
            if (err) { alert('å—ä¿¡æº–å‚™ã‚¨ãƒ©ãƒ¼: ' + err); client.end(); }
            else { alert('å—ä¿¡å¾…æ©Ÿä¸­ã§ã™ã€‚é€ä¿¡å´ã§åŒæœŸãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚'); }
          });
        }
      });

      client.on('message', (receivedTopic, message) => {
        if (receivedTopic === topic && isReceiving) {
          const newText = message.toString();
          memo.innerText = newText;
          rawText = getMemoTextForCount();
          hasExplicitBreaks = /\n/.test(memo.innerText) && !_isVisuallyEmptyMemo();
          history.push(rawText);
          currentStep = history.length - 1;
          alert('å—ä¿¡ã—ã¾ã—ãŸã€‚');
          client.end();
          transformWindow.style.display = 'none';
          updateCharCount();
        }
      });

      client.on('error', (err) => {
        alert('åŒæœŸæ¥ç¶šã‚¨ãƒ©ãƒ¼: ' + err.message);
        client.end();
      });
    });

    // ====== æ–‡å­—æ•°ãƒœã‚¿ãƒ³ã®UI ======
    charCountBtn.addEventListener('click', () => {
      if (charCountMenu.style.display === 'block') {
        charCountMenu.style.display = 'none';
      } else {
        showCountMenuNearButton();
      }
    });
    charCountMenu.addEventListener('change', (e) => {
      if (e.target.name === 'countMode') {
        countMode = e.target.value;
        updateCharCount();
        charCountMenu.style.display = 'none';
      }
    });
    document.addEventListener('click', (e) => {
      if (e.target !== charCountBtn && !charCountMenu.contains(e.target)) {
        charCountMenu.style.display = 'none';
      }
    }, true);

    // ====== åˆæœŸåŒ–ï¼šå¸¸ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã™ ======
    (function initCountMode() {
      countMode = 'default';
      const defaultRadio = document.querySelector('input[name="countMode"][value="default"]');
      if (defaultRadio) defaultRadio.checked = true;
      // åˆæœŸçŠ¶æ…‹ã§ã¯æ˜ç¤ºæ”¹è¡Œãªã—
      hasExplicitBreaks = false;
      updateCharCount();
    })();

  </script>
</body>
</html>
